<!DOCTYPE html>
<html lang="en">

<head>
    <!--<link rel="manifest" href="/manifest.webmanifest">-->
    <title>TV</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
    <script src="/js/mp4box.all.min.js"></script>

    <style>
        body {
            font-family: 'Roboto', 'Calibri', sans-serif;
            box-sizing: border-box;
            margin: 0;
            background-color: #334;
            min-height: 100vh;
            color: white;
        }

        video, img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: contain;
        }

        #controls {
            z-index: 10;
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>

<body>

<video id="video" controls style="display: none;"></video>
<img id="image" style="display: none;">
<div id="controls">
    <button id="allowAccess" onclick="getFile()">Allow access</button>
    <div id="peerId">We're opening the gate for you, it shouldn't take too long.</div>
</div>

<script src="https://unpkg.com/peerjs@1.3.1/dist/peerjs.min.js"></script>
<script src="/js/subtitles-octopus.js"></script>

<script>
    let directoryHandle, connection;
    /**
     * @type {HTMLVideoElement}
     */
    const video = document.getElementById("video");
    const image = document.getElementById("image");
    const controls = document.getElementById("controls");

    const peer = new Peer({
        host: window.location.hostname,
        port: 443,
        path: '/peerjs/myapp',
        secure: true,
    });

    video.addEventListener("play", () => {
        controls.style.display = "none";
    });
    video.addEventListener("pause", () => {
        controls.style.display = "block";
    });

    peer.on("open", (id) => {
        document.getElementById("peerId").innerText = "You're successfully connected, your id is: " + id;
    });

    let instance;
    peer.on('connection', (conn) => {
        if (connection) connection.close(); // Disconnect previously connected user
        connection = conn;

        conn.on("data", async (data) => {
            if (!directoryHandle) return;

            // Receive instruction
            const [action, content] = data;
            /**
             * @type {FileSystemFileHandle|FileSystemDirectoryHandle}
             */
            let handler;
            /**
             * @type {File}
             */
            let file;

            switch (action) {
                case "dir": {
                    handler = await findHandler(directoryHandle, content);
                    const res = await serializeDirectory(handler);
                    conn.send(["dir", res]);
                    break;
                }
                case "file": {
                    const path = Array.from(content);
                    const filename = path.pop();
                    const fileDirectoryHandle = await findHandler(directoryHandle, path);
                    const handler = await findHandler(fileDirectoryHandle, [filename]);
                    file = await handler.getFile();

                    switch (file.type.split("/")[0]) {
                        case "video": {
                            const subtitles = await findHandler(fileDirectoryHandle, [filename.replace(".mp4", ".fr-FR.ass")]);

                            const options = {
                                video: video, // HTML5 video element
                                subUrl: URL.createObjectURL(await subtitles.getFile()), // Link to subtitles
                                workerUrl: '/js/subtitles-octopus-worker.js', // Link to WebAssembly-based file "libassjs-worker.js"
                                legacyWorkerUrl: '/js/subtitles-octopus-worker-legacy.js' // Link to non-WebAssembly worker
                            };
                            instance?.dispose();
                            instance = new SubtitlesOctopus(options);

                            video.src = URL.createObjectURL(file);
                            image.style.display = "none";
                            video.style.display = "block";
                            video.play();
                            break;
                        }
                        case "image": {
                            image.src = URL.createObjectURL(file);
                            image.style.display = "block";
                            video.style.display = "none";
                            video.pause();
                            break;
                        }
                    }
                    break;
                }
                case "controls": {
                    switch (content) {
                        case "toggle":
                            if (video.paused) video.play();
                            else video.pause();
                            break;
                        case "time+":
                            video.currentTime = Math.min(video.duration, video.currentTime + 10);
                            break;
                        case "time-":
                            video.currentTime = Math.max(0, video.currentTime - 10);
                            break;
                    }
                    break;
                }
            }
        });

        conn.on("open", async () => {
            instance?.dispose();
            if (directoryHandle)
                conn.send(["dir", await serializeDirectory(directoryHandle)]);
        });
    });

    /**
     * @param {FileSystemDirectoryHandle} root
     * @param {string[]} path
     * @returns {Promise<FileSystemFileHandle|FileSystemDirectoryHandle>}
     */
    async function findHandler(root, path = []) {
        const entries = root.entries();
        let entry;
        while ((entry = await entries.next()).done === false) {
            const [name, handle] = entry.value;

            if (name === path[0]) {
                if (path.length === 1) {
                    return handle;
                } else {
                    return await findHandler(handle, path.slice(1));
                }
            }
        }

        return root;
    }

    /**
     * @param {FileSystemDirectoryHandle} directoryHandle
     * @returns {Promise<void>}
     */
    async function serializeDirectory(directoryHandle) {
        const response = [];

        const entries = directoryHandle.entries();
        let entry;
        while ((entry = await entries.next()).done === false) {
            const [name, handle] = entry.value;

            if (handle.kind === "file") {
                const type = (await handle.getFile()).type.split("/")[0];

                if (type === "video" || type === "image") {
                    response.push([name, handle.kind]);
                }
            } else {
                response.push([name, handle.kind]);
            }
        }

        return response;
    }

    async function getFile() {
        // Open directory picker
        directoryHandle = await window.showDirectoryPicker();

        document.getElementById("allowAccess").innerText = "Folder opened: " + directoryHandle.name;

        if (connection)
            connection.send(["dir", await serializeDirectory(directoryHandle)]);
    }
</script>
</body>

</html>
